# -*- coding: utf-8 -*-
"""KD_TREES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/127i1aQIcUNReA-iBupPTE5POwdF3SlL4
"""

import numpy as np
import matplotlib.pyplot as plt

class Nodo:
    def __init__(self, punto, split_dim, izquierda=None, derecha=None):
        self.punto = punto
        self.split_dim = split_dim
        self.izquierda = izquierda
        self.derecha = derecha

def construir_arbol_kd(puntos, profundidad=0):
    if len(puntos) == 0:
        return None

    k = len(puntos[0])
    split_dim = profundidad % k

    puntos.sort(key=lambda x: x[split_dim])
    indice_mediano = len(puntos) // 2
    punto_mediano = puntos[indice_mediano]

    puntos_izquierda = puntos[:indice_mediano]
    puntos_derecha = puntos[indice_mediano + 1:]

    return Nodo(
        punto=punto_mediano,
        split_dim=split_dim,
        izquierda=construir_arbol_kd(puntos_izquierda, profundidad + 1),
        derecha=construir_arbol_kd(puntos_derecha, profundidad + 1)
    )

def distancia_cuadrada(punto1, punto2):
    return np.sum((np.array(punto1) - np.array(punto2)) ** 2)

def nearest_neighbor_search(arbol, punto_objetivo, profundidad=0, mejor=None):
    if arbol is None:
        return mejor

    k = len(punto_objetivo)
    split_dim = profundidad % k

    next_branch = None
    opposite_branch = None

    if punto_objetivo[split_dim] < arbol.punto[split_dim]:
        next_branch = arbol.izquierda
        opposite_branch = arbol.derecha
    else:
        next_branch = arbol.derecha
        opposite_branch = arbol.izquierda

    mejor = nearest_neighbor_search(next_branch, punto_objetivo, profundidad + 1, mejor)

    if mejor is None or distancia_cuadrada(punto_objetivo, arbol.punto) < distancia_cuadrada(punto_objetivo, mejor):
        mejor = arbol.punto

    if (punto_objetivo[split_dim] - arbol.punto[split_dim]) ** 2 < distancia_cuadrada(punto_objetivo, mejor):
        mejor = nearest_neighbor_search(opposite_branch, punto_objetivo, profundidad + 1, mejor)

    return mejor

def graficar_arbol_kd(arbol, punto_minimo, punto_maximo, ax=None):
    if ax is None:
        fig, ax = plt.subplots()

    if arbol is None:
        return

    k = len(punto_minimo)
    split_dim = arbol.split_dim

    if split_dim == 0:
        ax.plot([arbol.punto[0], arbol.punto[0]], [punto_minimo[1], punto_maximo[1]], color='black')
    else:
        ax.plot([punto_minimo[0], punto_maximo[0]], [arbol.punto[1], arbol.punto[1]], color='black')

    graficar_arbol_kd(arbol.izquierda, punto_minimo, arbol.punto, ax)
    graficar_arbol_kd(arbol.derecha, arbol.punto, punto_maximo, ax)

def graficar_puntos(puntos, ax=None):
    if ax is None:
        fig, ax = plt.subplots()

    x = [p[0] for p in puntos]
    y = [p[1] for p in puntos]
    ax.scatter(x, y, color='blue')

# Ejemplo de uso
puntos = [(5,4),(2,6),(13,3),(8,7),(3,1)]
punto_objetivo = (9,4)
arbol_kd = construir_arbol_kd(puntos)

# Visualización
fig, ax = plt.subplots()
graficar_arbol_kd(arbol_kd, (0, 0), (12, 10), ax)
graficar_puntos(puntos, ax)
ax.scatter(punto_objetivo[0], punto_objetivo[1], color='red', label='Punto Objetivo')
vecino_mas_cercano = nearest_neighbor_search(arbol_kd, punto_objetivo)
ax.scatter(vecino_mas_cercano[0], vecino_mas_cercano[1], color='green', label='Vecino más cercano')
ax.legend()
plt.xlabel('X')
plt.ylabel('Y')
plt.title('Visualización del Árbol KD')
plt.grid(True)
plt.show()